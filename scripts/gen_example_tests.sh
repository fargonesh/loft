#!/usr/bin/env bash
# Generate tests/examples.rs from the contents of the examples/ directory.
#
# Usage (run from the workspace root):
#   bash scripts/gen_example_tests.sh
#
# Pass --check to exit with a non-zero status if the file on disk is out of
# date (used by CI) without writing anything.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
WORKSPACE="$(dirname "$SCRIPT_DIR")"
EXAMPLES_DIR="$WORKSPACE/examples"
OUTPUT="$WORKSPACE/tests/examples.rs"

# ---------------------------------------------------------------------------
# Config
# ---------------------------------------------------------------------------

# Top-level .lf files whose names start with these prefixes are FFI-dependent
# and get compiled-out (commented) rather than turned into real tests.
FFI_PREFIX="ffi_"

# Top-level .lf files that require network access / external packages;
# they are included as #[ignore]d tests.
IGNORED_FILE="web_api_demo.lf"
IGNORED_REASON="requires network access or the 'std' package to be installed"

# ---------------------------------------------------------------------------
# Parse args
# ---------------------------------------------------------------------------

CHECK=0
for arg in "$@"; do
  case "$arg" in
    --check) CHECK=1 ;;
  esac
done

# ---------------------------------------------------------------------------
# Generator
# ---------------------------------------------------------------------------

generate() {
  # ---- boilerplate header --------------------------------------------------
  cat <<'HEADER'
// @generated by scripts/gen_example_tests.sh â€” DO NOT EDIT MANUALLY.
// Run `bash scripts/gen_example_tests.sh` to regenerate this file.
//
// Integration tests that run each example file through the loft binary.
//
// FFI examples are skipped because they require native shared libraries
// (e.g. libm.so.6) that are not guaranteed to be present in all environments.
// Network / external-package examples are included but marked #[ignore].
use std::path::Path;
use std::process::Command;

const LOFT: &str = env!("CARGO_BIN_EXE_loft");

/// Run a `.lf` file through the loft binary and assert it exits successfully.
///
/// `cwd` is the working directory passed to the process; use `Some(dir)` for
/// examples that `learn` relative paths (modules), otherwise pass `None`.
fn run_example(file: impl AsRef<Path>, cwd: Option<&Path>) {
    let file = file.as_ref();
    let mut cmd = Command::new(LOFT);
    cmd.arg("--allow-all")
        .arg(file.to_str().expect("non-UTF-8 path"));

    if let Some(dir) = cwd {
        cmd.current_dir(dir);
    }

    let output = cmd
        .output()
        .unwrap_or_else(|e| panic!("failed to spawn loft for {:?}: {}", file, e));

    if !output.status.success() {
        panic!(
            "example {:?} failed with status {}\n--- stdout ---\n{}\n--- stderr ---\n{}",
            file,
            output.status,
            String::from_utf8_lossy(&output.stdout),
            String::from_utf8_lossy(&output.stderr),
        );
    }
}
HEADER

  # ---- collect and categorise .lf files ------------------------------------
  ffi_files=()
  normal_files=()
  ignored_files=()

  while IFS= read -r -d '' f; do
    name="$(basename "$f")"
    case "$name" in
      "${FFI_PREFIX}"*) ffi_files+=("$name") ;;
      "$IGNORED_FILE")  ignored_files+=("$name") ;;
      *)                normal_files+=("$name") ;;
    esac
  done < <(find "$EXAMPLES_DIR" -maxdepth 1 -name '*.lf' -print0 | sort -z)

  # ---- normal tests --------------------------------------------------------
  printf '// ---------------------------------------------------------------------------\n'
  printf '// Individual example tests\n'
  printf '// ---------------------------------------------------------------------------\n'
  printf '\n'

  for name in "${normal_files[@]+"${normal_files[@]}"}"; do
    stem="${name%.lf}"
    fn="${stem//-/_}"
    printf '#[test]\nfn example_%s() {\n    run_example("examples/%s", None);\n}\n\n' \
      "$fn" "$name"
  done

  # ---- ignored tests -------------------------------------------------------
  if [ "${#ignored_files[@]}" -gt 0 ]; then
    printf '// ---------------------------------------------------------------------------\n'
    printf '// Examples that require external resources (run with --ignored)\n'
    printf '// ---------------------------------------------------------------------------\n'
    printf '\n'
    for name in "${ignored_files[@]}"; do
      stem="${name%.lf}"
      fn="${stem//-/_}"
      printf '/// Requires external resources; run manually with\n'
      printf '/// `cargo test -- --ignored` once they are available.\n'
      printf '#[test]\n'
      printf '#[ignore = "%s"]\n' "$IGNORED_REASON"
      printf 'fn example_%s() {\n    run_example("examples/%s", None);\n}\n\n' \
        "$fn" "$name"
    done
  fi

  # ---- module tests --------------------------------------------------------
  if [ -f "$EXAMPLES_DIR/modules/main.lf" ]; then
    printf '// ---------------------------------------------------------------------------\n'
    printf '// Module examples\n'
    printf '// ---------------------------------------------------------------------------\n'
    printf '\n'
    cat <<'MODULES'
/// Module examples use `learn` with relative paths, so the process must run
/// from the directory that contains the module files.
#[test]
fn example_modules_main() {
    let cwd = Path::new("examples/modules");
    run_example(
        Path::new("examples/modules/main.lf")
            .canonicalize()
            .unwrap_or_else(|_| Path::new("examples/modules/main.lf").to_path_buf()),
        Some(cwd),
    );
}
MODULES
  fi

  # ---- FFI section (commented-out) -----------------------------------------
  if [ "${#ffi_files[@]}" -gt 0 ]; then
    printf '// ---------------------------------------------------------------------------\n'
    printf '// FFI examples are skipped \xe2\x80\x93 they require native shared libraries at runtime.\n'
    printf '//\n'
    for name in "${ffi_files[@]}"; do
      stem="${name%.lf}"
      fn="${stem//-/_}"
      printf '// #[test]\n// fn example_%s() { run_example("examples/%s", None); }\n' \
        "$fn" "$name"
    done
    printf '// ---------------------------------------------------------------------------\n'
  fi
}

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

if [ "$CHECK" -eq 1 ]; then
  tmpfile="$(mktemp)"
  trap 'rm -f "$tmpfile"' EXIT
  generate > "$tmpfile"
  if ! diff -q "$OUTPUT" "$tmpfile" > /dev/null 2>&1; then
    echo "ERROR: tests/examples.rs is out of date." >&2
    echo "Run \`bash scripts/gen_example_tests.sh\` and commit the result." >&2
    diff "$OUTPUT" "$tmpfile" >&2 || true
    exit 1
  fi
  echo "tests/examples.rs is up to date."
else
  generate > "$OUTPUT"
  rel="${OUTPUT#"$WORKSPACE/"}"
  echo "Wrote $rel"
fi
